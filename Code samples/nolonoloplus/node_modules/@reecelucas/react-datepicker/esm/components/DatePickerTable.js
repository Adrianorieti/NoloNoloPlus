var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { eachDayOfInterval, format, getDate, startOfMonth, lastDayOfMonth } from 'date-fns';
import { StateContext, DispatchContext } from './DatePickerContext';
import * as actionTypes from '../reducer/actionTypes';
import { chunkArray } from '../helpers/array';
import { isFunction } from '../helpers/function';
import { dateIsSelectable, getDayRemapped, getWeekDays, isEqualDate } from '../helpers/date';
var DatePickerCalendar = function (_a) {
    var renderDayLabel = _a.renderDayLabel, renderDayContent = _a.renderDayContent, props = __rest(_a, ["renderDayLabel", "renderDayContent"]);
    var dispatch = React.useContext(DispatchContext);
    var _b = React.useContext(StateContext), year = _b.year, month = _b.month, selectedDate = _b.selectedDate, focussedDate = _b.focussedDate, allowCellFocus = _b.allowCellFocus, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, locale = _b.locale;
    var monthStartDate = startOfMonth(new Date(year, month));
    var monthEndDate = lastDayOfMonth(new Date(year, month));
    var monthDates = eachDayOfInterval({
        start: monthStartDate,
        end: monthEndDate
    });
    var numberOfBlanks = getDayRemapped(new Date(year, month));
    var blanks = Array.from(Array(numberOfBlanks).keys()).map(function () { return ''; });
    var cells = blanks.concat(monthDates);
    var rows = chunkArray(cells, 7);
    var renderWeekdays = function () {
        return getWeekDays(locale).map(function (day) { return React.createElement("th", { key: day }, day); });
    };
    var renderAriaLabel = function (_a) {
        var date = _a.date, isSelected = _a.isSelected, isSelectable = _a.isSelectable;
        var status = isSelected
            ? 'Selected. '
            : "" + (isSelectable ? 'Available. ' : 'Not Available. ');
        return isFunction(renderDayLabel)
            ? renderDayLabel({ date: date, isSelected: isSelected, isSelectable: isSelectable })
            : "" + status + format(date, 'eeee, do MMMM yyyy', { locale: locale }) + ".";
    };
    var renderTableRows = function () {
        return rows.map(function (row, rowIndex) { return (React.createElement("tr", { key: rowIndex }, row.map(function (date, dateIndex) {
            return date ? renderCell(date) : React.createElement("td", { key: dateIndex });
        }))); });
    };
    var renderCell = function (date) {
        var d = new Date(date);
        var isFocussed = allowCellFocus && isEqualDate(focussedDate, d);
        var isSelected = isEqualDate(selectedDate, d);
        var isSelectable = dateIsSelectable({
            date: d,
            minDate: minDate,
            maxDate: maxDate,
            excludeDates: excludeDates,
            includeDates: includeDates
        });
        return (React.createElement("td", { key: d.toString(), role: 'button', "aria-label": renderAriaLabel({ date: d, isSelected: isSelected, isSelectable: isSelectable }), "aria-disabled": isSelectable ? 'false' : 'true', "aria-selected": isSelected ? 'true' : 'false', tabIndex: isSelected || isFocussed ? 0 : -1, onClick: function () {
                return isSelectable &&
                    dispatch({ type: actionTypes.SET_SELECTED_DATE, payload: d });
            }, ref: function (ref) {
                if (ref && isFocussed) {
                    ref.focus();
                }
            } },
            React.createElement("span", { "aria-hidden": 'true' }, isFunction(renderDayContent) ? renderDayContent(d) : getDate(d))));
    };
    return (React.createElement("table", __assign({}, props),
        React.createElement("thead", null,
            React.createElement("tr", null, renderWeekdays())),
        React.createElement("tbody", null, renderTableRows())));
};
export default DatePickerCalendar;

"use strict"; var precacheConfig = [["/index.html", "7e3185303bdd1052a47f3efa879af29f"], ["/static/css/main.936fc0b8.chunk.css", "bcb10e8769372267eeaaabfe352e0028"], ["/static/js/1.aee8566e.chunk.js", "feb5d8b75ca78b8c8c60cf14f124b4c6"], ["/static/js/2.9ef1d2d1.chunk.js", "72dd1399e5e83fb44200594d39b140eb"], ["/static/js/3.01c3c639.chunk.js", "7b011aff5446e74b11fb8b9ee1fe4441"], ["/static/js/4.5f65880f.chunk.js", "7011e1e23aaa59c36f41e55dbb424454"], ["/static/js/main.acabb709.chunk.js", "1f3268bc72d4d157f2f4ba7c94e06178"], ["/static/js/runtime~main.4284a81f.js", "a93ceb453c8cc1f525bab4ecfa6a87f2"], ["/static/media/NoloNoloLogo.bfbf868f.png", "bfbf868fd079e27fed91bd0f1048466d"], ["/static/media/bikeTravel1.d3b5e660.jpg", "d3b5e660bc9a75025b0789093556e021"], ["/static/media/bikeTravel2.980b1da8.jpg", "980b1da88203a27981d5eb9121529b1b"], ["/static/media/bikeTravel3.2ff7b718.jpg", "2ff7b718d5ae5e4089098a66ba895b80"], ["/static/media/bikes.41a74106.jpg", "41a74106b020ab255121b960d9981c70"], ["/static/media/how-it-works-1.917a1d63.svg", "917a1d63426524b3361d391e89c3f5c3"], ["/static/media/how-it-works-2.684aa422.svg", "684aa422055f23e39be8b604ea2a49be"], ["/static/media/how-it-works-3.0ad31d53.svg", "0ad31d530b420ba71b2cd57f0a5c5623"], ["/static/media/texture-of-bicycle.757b9981.jpg", "757b9981dc68c05f5a8151625e8e1d0b"], ["/static/media/treehd.4d0753df.jpg", "4d0753df12b3cb732f846ced282d1e2c"]], cacheName = "sw-precache-v3-sw-precache-webpack-plugin-" + (self.registration ? self.registration.scope : ""), ignoreUrlParametersMatching = [/^utm_/], addDirectoryIndex = function (e, t) { var a = new URL(e); return "/" === a.pathname.slice(-1) && (a.pathname += t), a.toString() }, cleanResponse = function (e) { return e.redirected ? ("body" in e ? Promise.resolve(e.body) : e.blob()).then(function (t) { return new Response(t, { headers: e.headers, status: e.status, statusText: e.statusText }) }) : Promise.resolve(e) }, createCacheKey = function (e, t, a, n) { var r = new URL(e); return n && r.pathname.match(n) || (r.search += (r.search ? "&" : "") + encodeURIComponent(t) + "=" + encodeURIComponent(a)), r.toString() }, isPathWhitelisted = function (e, t) { if (0 === e.length) return !0; var a = new URL(t).pathname; return e.some(function (e) { return a.match(e) }) }, stripIgnoredUrlParameters = function (e, t) { var a = new URL(e); return a.hash = "", a.search = a.search.slice(1).split("&").map(function (e) { return e.split("=") }).filter(function (e) { return t.every(function (t) { return !t.test(e[0]) }) }).map(function (e) { return e.join("=") }).join("&"), a.toString() }, hashParamName = "_sw-precache", urlsToCacheKeys = new Map(precacheConfig.map(function (e) { var t = e[0], a = e[1], n = new URL(t, self.location), r = createCacheKey(n, hashParamName, a, /\.\w{8}\./); return [n.toString(), r] })); function setOfCachedUrls(e) { return e.keys().then(function (e) { return e.map(function (e) { return e.url }) }).then(function (e) { return new Set(e) }) } self.addEventListener("install", function (e) { e.waitUntil(caches.open(cacheName).then(function (e) { return setOfCachedUrls(e).then(function (t) { return Promise.all(Array.from(urlsToCacheKeys.values()).map(function (a) { if (!t.has(a)) { var n = new Request(a, { credentials: "same-origin" }); return fetch(n).then(function (t) { if (!t.ok) throw new Error("Request for " + a + " returned a response with status " + t.status); return cleanResponse(t).then(function (t) { return e.put(a, t) }) }) } })) }) }).then(function () { })) }), self.addEventListener("activate", function (e) { var t = new Set(urlsToCacheKeys.values()); e.waitUntil(caches.open(cacheName).then(function (e) { return e.keys().then(function (a) { return Promise.all(a.map(function (a) { if (!t.has(a.url)) return e.delete(a) })) }) }).then(function () { return self.clients.claim() })) }), self.addEventListener("fetch", function (e) { if ("GET" === e.request.method) { var t, a = stripIgnoredUrlParameters(e.request.url, ignoreUrlParametersMatching); (t = urlsToCacheKeys.has(a)) || (a = addDirectoryIndex(a, "index.html"), t = urlsToCacheKeys.has(a)); !t && "navigate" === e.request.mode && isPathWhitelisted(["^(?!\\/__).*"], e.request.url) && (a = new URL("/index.html", self.location).toString(), t = urlsToCacheKeys.has(a)), t && e.respondWith(caches.open(cacheName).then(function (e) { return e.match(urlsToCacheKeys.get(a)).then(function (e) { if (e) return e; throw Error("The cached response that was expected is missing.") }) }).catch(function (t) { return console.warn('Couldn\'t serve response for "%s" from cache: %O', e.request.url, t), fetch(e.request) })) } });
